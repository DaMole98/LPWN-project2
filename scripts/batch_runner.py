import os
import subprocess
import time

# Number of identical simulation runs to execute in batch
NUM_RUNS = 100

# Paths for the simulation file and the report file
simulation_file = "test_nogui_dc.csc"
safe_simulation_name = os.path.splitext(simulation_file.replace("/", "_"))[0]
report_file = "BATCH_report_{}.txt".format(safe_simulation_name)

# Log file generated by the simulation
log_file = "test.log"

# Clear the report file at the beginning
open(report_file, "w").close()

# Execute the simulation runs in a loop
for run in range(1, NUM_RUNS + 1):
    try:
        print(f"Executing simulation run {run}/{NUM_RUNS}...")

        # Compile the code
        print("Compiling the code...")
        subprocess.call(["make"])

        # Run the simulation with cooja_nogui and capture the output in real time
        print("Running simulation with cooja_nogui...")
        sim_process = subprocess.Popen(
            ["cooja_nogui", simulation_file],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True
        )

        # Print the simulation output (stdout and stderr) in real time
        for line in iter(sim_process.stdout.readline, ""):
            print(line.strip())
        for line in iter(sim_process.stderr.readline, ""):
            print(line.strip())

        sim_process.wait()

        # Check the simulation return code; accept 0 and 1 (1 if log is produced)
        if sim_process.returncode not in [0, 1]:
            raise Exception(f"Error running cooja_nogui (exit code {sim_process.returncode})")

        # Wait until the log file is created and has content
        max_wait_time = 300  # Maximum wait time in seconds
        wait_time = 0
        while not os.path.exists(log_file) or os.stat(log_file).st_size == 0:
            if wait_time > max_wait_time:
                raise Exception(f"Simulation did not generate log within {max_wait_time} seconds.")
            time.sleep(5)
            wait_time += 5
            print(f"Waiting for log file generation ({wait_time}/{max_wait_time} sec)...")

        # Analyze the log using parser.py
        subprocess.call(["python", "parser.py", log_file, "--cooja"])

        # Run the analysis using analysis.py
        analysis_process = subprocess.Popen(
            ["python", "analysis.py", ".", "--cooja"],
            stdout=subprocess.PIPE,
            universal_newlines=True
        )
        analysis_result, _ = analysis_process.communicate()

        # Write simulation run details and analysis results to the report file
        with open(report_file, "a") as report:
            report.write("\n" + "=" * 100 + "\n")
            report.write(f" Simulation File: {simulation_file} - Run {run}/{NUM_RUNS} \n")
            report.write("=" * 100 + "\n")
            report.write("\n>>> SIMULATION DETAILS <<<\n")
            report.write(f"Run number: {run}\n")
            report.write("\n>>> ANALYSIS RESULTS <<<\n")
            report.write(analysis_result)
            report.flush()

        print(f"Run {run}/{NUM_RUNS} completed. Results saved.")

    except Exception as e:
        print(f"Error during run {run}/{NUM_RUNS}: {e}")
        with open(report_file, "a") as report:
            report.write("\n" + "=" * 100 + "\n")
            report.write(f" RUN {run}/{NUM_RUNS} - FAILED \n")
            report.write("=" * 100 + "\n")
            report.write("\n>>> ERROR <<<\n")
            report.write(str(e) + "\n")
            report.flush()

print(f"Batch simulation completed. Results saved in {report_file}")
